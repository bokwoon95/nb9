package nb9

import (
	"context"
	"io"
	"io/fs"
	"os"
	"path/filepath"
	"runtime"
	"strings"
)

type LocalFSConfig struct {
	// RootDir is the root directory of the LocalFS.
	RootDir string

	// TempDir is the temp directory of the LocalFS.
	TempDir string
}

// LocalFS represents a filesystem rooted on a local directory.
type LocalFS struct {
	// Context provides the context of all operations called on the LocalFS.
	Context context.Context

	// RootDir is the root directory of the LocalFS. Has to be an absolute
	// path!!
	RootDir string

	// TempDir is the temp directory of the LocalFS. Files are first written to
	// the TempDir before being swapped into the rootDir via an atomic rename
	// (windows is the exception I've found the renames there to be BUGGY AF!
	// *insert github issue where rename on windows keep failing intermittently
	// with an annoying permission error*)
	TempDir string
}

func NewLocalFS(config LocalFSConfig) (*LocalFS, error) {
	rootDir, err := filepath.Abs(filepath.FromSlash(config.RootDir))
	if err != nil {
		return nil, err
	}
	tempDir, err := filepath.Abs(filepath.FromSlash(config.TempDir))
	if err != nil {
		return nil, err
	}
	localFS := &LocalFS{
		Context: context.Background(),
		RootDir: rootDir,
		TempDir: tempDir,
	}
	return localFS, nil
}

func (fsys *LocalFS) WithContext(ctx context.Context) FS {
	return &LocalFS{
		Context: ctx,
		RootDir: fsys.RootDir,
		TempDir: fsys.TempDir,
	}
}

func (fsys *LocalFS) Open(name string) (fs.File, error) {
	err := fsys.Context.Err()
	if err != nil {
		return nil, err
	}
	if !fs.ValidPath(name) || strings.Contains(name, "\\") {
		return nil, &fs.PathError{Op: "open", Path: name, Err: fs.ErrInvalid}
	}
	name = filepath.FromSlash(name)
	file, err := os.Open(filepath.Join(fsys.RootDir, name))
	if err != nil {
		return nil, err
	}
	return file, nil
}

func (fsys *LocalFS) Stat(name string) (fs.FileInfo, error) {
	err := fsys.Context.Err()
	if err != nil {
		return nil, err
	}
	if !fs.ValidPath(name) || strings.Contains(name, "\\") {
		return nil, &fs.PathError{Op: "stat", Path: name, Err: fs.ErrInvalid}
	}
	name = filepath.FromSlash(name)
	fileInfo, err := os.Stat(filepath.Join(fsys.RootDir, name))
	if err != nil {
		return nil, err
	}
	return fileInfo, nil
}

func (fsys *LocalFS) OpenWriter(name string, _ fs.FileMode) (io.WriteCloser, error) {
	err := fsys.Context.Err()
	if err != nil {
		return nil, err
	}
	if !fs.ValidPath(name) || strings.Contains(name, "\\") {
		return nil, &fs.PathError{Op: "openwriter", Path: name, Err: fs.ErrInvalid}
	}
	if runtime.GOOS == "windows" {
		file, err := os.OpenFile(filepath.Join(fsys.RootDir, name), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
		if err != nil {
			return nil, err
		}
		return file, nil
	}
	file := &LocalFileWriter{
		ctx:     fsys.Context,
		rootDir: fsys.RootDir,
		tempDir: fsys.TempDir,
		name:    filepath.FromSlash(name),
	}
	if file.tempDir == "" {
		file.tempDir = os.TempDir()
	}
	file.tempFile, err = os.CreateTemp(file.tempDir, "__notebrewtemp*__")
	if err != nil {
		return nil, err
	}
	fileInfo, err := file.tempFile.Stat()
	if err != nil {
		return nil, err
	}
	file.tempName = fileInfo.Name()
	return file, nil
}

// LocalFileWriter represents a writable file on a LocalFS.
type LocalFileWriter struct {
	// ctx provides the context of all operations called on the file.
	ctx context.Context

	// rootDir is the root directory that houses the destination file.
	rootDir string

	// name is the name of the destination file relative to rootDir.
	name string

	// tempFile is temporary file we are writing to first before we do an
	// atomic rename into the destination file. This ensures that parallel
	// writers do not corrupt the destination file, writes are always all or
	// nothing and the last writer wins.
	tempFile *os.File

	// tempDir is the temp directory that houses the temporary file.
	tempDir string

	// tempName is the name of the temporary file relative to tempDir. It is
	// randomly generated by os.CreateTemp.
	tempName string

	// writeFailed records if any writes to the tempFile failed.
	writeFailed bool
}

func (file *LocalFileWriter) ReadFrom(r io.Reader) (n int64, err error) {
	err = file.ctx.Err()
	if err != nil {
		file.writeFailed = true
		return 0, err
	}
	n, err = file.tempFile.ReadFrom(r)
	if err != nil {
		file.writeFailed = true
		return n, err
	}
	return n, nil
}

func (file *LocalFileWriter) Write(p []byte) (n int, err error) {
	err = file.ctx.Err()
	if err != nil {
		file.writeFailed = true
		return 0, err
	}
	n, err = file.tempFile.Write(p)
	if err != nil {
		file.writeFailed = true
		return n, err
	}
	return n, nil
}

func (file *LocalFileWriter) Close() error {
	tempFilePath := filepath.Join(file.tempDir, file.tempName)
	destFilePath := filepath.Join(file.rootDir, file.name)
	defer os.Remove(tempFilePath)
	err := file.tempFile.Close()
	if err != nil {
		return err
	}
	if file.writeFailed {
		return nil
	}
	err = os.Rename(tempFilePath, destFilePath)
	if err != nil {
		return err
	}
	return nil
}

func (fsys *LocalFS) ReadDir(name string) ([]fs.DirEntry, error) {
	err := fsys.Context.Err()
	if err != nil {
		return nil, err
	}
	if !fs.ValidPath(name) || strings.Contains(name, "\\") {
		return nil, &fs.PathError{Op: "mkdir", Path: name, Err: fs.ErrInvalid}
	}
	name = filepath.FromSlash(name)
	return os.ReadDir(filepath.Join(fsys.RootDir, name))
}

func (fsys *LocalFS) Mkdir(name string, _ fs.FileMode) error {
	err := fsys.Context.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(name) || strings.Contains(name, "\\") {
		return &fs.PathError{Op: "mkdir", Path: name, Err: fs.ErrInvalid}
	}
	name = filepath.FromSlash(name)
	return os.Mkdir(filepath.Join(fsys.RootDir, name), 0755)
}

func (fsys *LocalFS) MkdirAll(name string, _ fs.FileMode) error {
	err := fsys.Context.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(name) || strings.Contains(name, "\\") {
		return &fs.PathError{Op: "mkdirall", Path: name, Err: fs.ErrInvalid}
	}
	name = filepath.FromSlash(name)
	return os.MkdirAll(filepath.Join(fsys.RootDir, name), 0755)
}

func (fsys *LocalFS) Remove(name string) error {
	err := fsys.Context.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(name) || strings.Contains(name, "\\") {
		return &fs.PathError{Op: "remove", Path: name, Err: fs.ErrInvalid}
	}
	name = filepath.FromSlash(name)
	return os.Remove(filepath.Join(fsys.RootDir, name))
}

func (fsys *LocalFS) RemoveAll(name string) error {
	err := fsys.Context.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(name) || strings.Contains(name, "\\") {
		return &fs.PathError{Op: "removeall", Path: name, Err: fs.ErrInvalid}
	}
	name = filepath.FromSlash(name)
	return os.RemoveAll(filepath.Join(fsys.RootDir, name))
}

func (fsys *LocalFS) Rename(oldname, newname string) error {
	err := fsys.Context.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(oldname) || strings.Contains(oldname, "\\") {
		return &fs.PathError{Op: "rename", Path: oldname, Err: fs.ErrInvalid}
	}
	if !fs.ValidPath(newname) || strings.Contains(newname, "\\") {
		return &fs.PathError{Op: "rename", Path: newname, Err: fs.ErrInvalid}
	}
	oldname = filepath.FromSlash(oldname)
	newname = filepath.FromSlash(newname)
	return os.Rename(filepath.Join(fsys.RootDir, oldname), filepath.Join(fsys.RootDir, newname))
}
