package nb9

import (
	"bytes"
	"context"
	"crypto/rand"
	"database/sql"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"os"
	"path"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/credentials"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"github.com/aws/smithy-go"
	"github.com/bokwoon95/nb9/sq"
	"golang.org/x/sync/errgroup"
)

var bufPool = sync.Pool{
	New: func() any { return &bytes.Buffer{} },
}

type FS interface {
	// WithContext returns a new FS with the given context.
	WithContext(context.Context) FS

	// Open opens the named file.
	Open(name string) (fs.File, error)

	// OpenWriter opens an io.WriteCloser that represents an instance of a
	// file. The parent directory must exist. If the file doesn't exist, it
	// should be created. If the file exists, its should be truncated.
	OpenWriter(name string, perm fs.FileMode) (io.WriteCloser, error)

	// Mkdir creates a new directory with the specified name.
	Mkdir(dir string, perm fs.FileMode) error

	ScanDir(dir string, fn func(fs.DirEntry) error) error

	ScanDirFiles(dir string, fn func(fs.File) error) error

	WalkDirFiles(dir string, fn func(filePath string, file fs.File, err error) error) error

	// Remove removes the named file or directory.
	Remove(name string) error

	// Rename renames (moves) oldname to newname. If newname already exists and
	// is not a directory, Rename replaces it.
	Rename(oldname, newname string) error
}

// LocalFS represents a filesystem rooted on a local directory.
type LocalFS struct {
	// ctx provides the context of all operations called on the LocalFS.
	ctx context.Context

	// rootDir is the root directory of the LocalFS.
	rootDir string

	// tempDir is the temp directory of the LocalFS. Files are first written to
	// the tempDir before being swapped into the rootDir via an atomic rename
	// (windows is the exception I've found the renames there to be BUGGY AF!
	// *insert github issue where rename on windows keep failing intermittently
	// with an annoying permission error*)
	tempDir string
}

func NewLocalFS(rootDir, tempDir string) *LocalFS {
	return &LocalFS{
		ctx:     context.Background(),
		rootDir: filepath.FromSlash(rootDir),
		tempDir: filepath.FromSlash(tempDir),
	}
}

func (fsys *LocalFS) WithContext(ctx context.Context) FS {
	return &LocalFS{
		ctx:     ctx,
		rootDir: fsys.rootDir,
		tempDir: fsys.tempDir,
	}
}

func (fsys *LocalFS) Stat(name string) (fs.FileInfo, error) {
	err := fsys.ctx.Err()
	if err != nil {
		return nil, err
	}
	if !fs.ValidPath(name) || strings.Contains(name, "\\") {
		return nil, &fs.PathError{Op: "stat", Path: name, Err: fs.ErrInvalid}
	}
	name = filepath.FromSlash(name)
	return os.Stat(filepath.Join(fsys.rootDir, name))
}

func (fsys *LocalFS) Open(name string) (fs.File, error) {
	err := fsys.ctx.Err()
	if err != nil {
		return nil, err
	}
	if !fs.ValidPath(name) || strings.Contains(name, "\\") {
		return nil, &fs.PathError{Op: "open", Path: name, Err: fs.ErrInvalid}
	}
	name = filepath.FromSlash(name)
	file, err := os.Open(filepath.Join(fsys.rootDir, name))
	if err != nil {
		return nil, err
	}
	return file, nil
}

func (fsys *LocalFS) OpenWriter(name string, _ fs.FileMode) (io.WriteCloser, error) {
	err := fsys.ctx.Err()
	if err != nil {
		return nil, err
	}
	if !fs.ValidPath(name) || strings.Contains(name, "\\") {
		return nil, &fs.PathError{Op: "openwriter", Path: name, Err: fs.ErrInvalid}
	}
	if runtime.GOOS == "windows" {
		file, err := os.OpenFile(filepath.Join(fsys.rootDir, name), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
		if err != nil {
			return nil, err
		}
		return file, nil
	}
	file := &LocalFileWriter{
		ctx:     fsys.ctx,
		rootDir: fsys.rootDir,
		tempDir: fsys.tempDir,
		name:    filepath.FromSlash(name),
	}
	if file.tempDir == "" {
		file.tempDir = os.TempDir()
	}
	file.tempFile, err = os.CreateTemp(file.tempDir, "__notebrewtemp*__")
	if err != nil {
		return nil, err
	}
	fileInfo, err := file.tempFile.Stat()
	if err != nil {
		return nil, err
	}
	file.tempName = fileInfo.Name()
	return file, nil
}

// LocalFileWriter represents a writable file on a LocalFS.
type LocalFileWriter struct {
	// ctx provides the context of all operations called on the file.
	ctx context.Context

	// rootDir is the root directory that houses the destination file.
	rootDir string

	// name is the name of the destination file relative to rootDir.
	name string

	// tempFile is temporary file we are writing to first before we do an
	// atomic rename into the destination file. This ensures that parallel
	// writers do not corrupt the destination file, writes are always all or
	// nothing and the last writer wins.
	tempFile *os.File

	// tempDir is the temp directory that houses the temporary file.
	tempDir string

	// tempName is the name of the temporary file relative to tempDir. It is
	// randomly generated by os.CreateTemp.
	tempName string

	// writeFailed records if any writes to the tempFile failed.
	writeFailed bool
}

func (file *LocalFileWriter) ReadFrom(r io.Reader) (n int64, err error) {
	err = file.ctx.Err()
	if err != nil {
		file.writeFailed = true
		return 0, err
	}
	n, err = file.tempFile.ReadFrom(r)
	if err != nil {
		file.writeFailed = true
		return n, err
	}
	return n, nil
}

func (file *LocalFileWriter) Write(p []byte) (n int, err error) {
	err = file.ctx.Err()
	if err != nil {
		file.writeFailed = true
		return 0, err
	}
	n, err = file.tempFile.Write(p)
	if err != nil {
		file.writeFailed = true
		return n, err
	}
	return n, nil
}

func (file *LocalFileWriter) Close() error {
	tempFilePath := filepath.Join(file.tempDir, file.tempName)
	destFilePath := filepath.Join(file.rootDir, file.name)
	defer os.Remove(tempFilePath)
	err := file.tempFile.Close()
	if err != nil {
		return err
	}
	if file.writeFailed {
		return nil
	}
	err = os.Rename(tempFilePath, destFilePath)
	if err != nil {
		return err
	}
	return nil
}

func (fsys *LocalFS) Mkdir(dir string, _ fs.FileMode) error {
	err := fsys.ctx.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(dir) || strings.Contains(dir, "\\") {
		return &fs.PathError{Op: "mkdir", Path: dir, Err: fs.ErrInvalid}
	}
	dir = filepath.FromSlash(dir)
	return os.Mkdir(filepath.Join(fsys.rootDir, dir), 0755)
}

func (fsys *LocalFS) MkdirAll(dir string, _ fs.FileMode) error {
	err := fsys.ctx.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(dir) || strings.Contains(dir, "\\") {
		return &fs.PathError{Op: "mkdirall", Path: dir, Err: fs.ErrInvalid}
	}
	dir = filepath.FromSlash(dir)
	return os.MkdirAll(filepath.Join(fsys.rootDir, dir), 0755)
}

func (fsys *LocalFS) ScanDir(dir string, fn func(fs.DirEntry) error) error {
	err := fsys.ctx.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(dir) || strings.Contains(dir, "\\") {
		return &fs.PathError{Op: "scandir", Path: dir, Err: fs.ErrInvalid}
	}
	file, err := os.Open(filepath.Join(fsys.rootDir, dir))
	if err != nil {
		return err
	}
	defer file.Close()
	fileInfo, err := file.Stat()
	if err != nil {
		return err
	}
	if !fileInfo.IsDir() {
		return &fs.PathError{Op: "scandir", Path: dir, Err: syscall.ENOTDIR}
	}
	for {
		dirEntries, err := file.ReadDir(1000)
		if err != nil {
			if err == io.EOF {
				break
			}
			return err
		}
		for _, dirEntry := range dirEntries {
			err = fn(dirEntry)
			if err == fs.SkipDir || err == fs.SkipAll {
				return nil
			}
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (fsys *LocalFS) ScanDirFiles(dir string, fn func(fs.File) error) error {
	err := fsys.ctx.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(dir) || strings.Contains(dir, "\\") {
		return &fs.PathError{Op: "scandirfiles", Path: dir, Err: fs.ErrInvalid}
	}
	file, err := os.Open(filepath.Join(fsys.rootDir, dir))
	if err != nil {
		return err
	}
	defer file.Close()
	fileInfo, err := file.Stat()
	if err != nil {
		return err
	}
	if !fileInfo.IsDir() {
		return &fs.PathError{Op: "scandirfiles", Path: dir, Err: syscall.ENOTDIR}
	}
	for {
		dirEntries, err := file.ReadDir(1000)
		if err != nil {
			if err == io.EOF {
				break
			}
			return err
		}
		for _, dirEntry := range dirEntries {
			file, err := os.Open(filepath.Join(fsys.rootDir, dir, dirEntry.Name()))
			if err != nil {
				return err
			}
			err = fn(file)
			if err == fs.SkipDir || err == fs.SkipAll {
				return nil
			}
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (fsys *LocalFS) WalkDirFiles(dir string, fn func(filePath string, file fs.File, err error) error) error {
	err := fsys.ctx.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(dir) || strings.Contains(dir, "\\") {
		return &fs.PathError{Op: "walkdirfiles", Path: dir, Err: fs.ErrInvalid}
	}
	return fs.WalkDir(os.DirFS(fsys.rootDir), dir, func(filePath string, dirEntry fs.DirEntry, err error) error {
		if err != nil {
			return fn(filePath, nil, err)
		}
		file, err := os.Open(filePath)
		if err != nil {
			return err
		}
		return fn(filePath, file, nil)
	})
}

func (fsys *LocalFS) Remove(name string) error {
	err := fsys.ctx.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(name) || strings.Contains(name, "\\") {
		return &fs.PathError{Op: "remove", Path: name, Err: fs.ErrInvalid}
	}
	name = filepath.FromSlash(name)
	return os.Remove(filepath.Join(fsys.rootDir, name))
}

func (fsys *LocalFS) RemoveAll(name string) error {
	err := fsys.ctx.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(name) || strings.Contains(name, "\\") {
		return &fs.PathError{Op: "removeall", Path: name, Err: fs.ErrInvalid}
	}
	name = filepath.FromSlash(name)
	return os.RemoveAll(filepath.Join(fsys.rootDir, name))
}

func (fsys *LocalFS) Rename(oldname, newname string) error {
	err := fsys.ctx.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(oldname) || strings.Contains(oldname, "\\") {
		return &fs.PathError{Op: "rename", Path: oldname, Err: fs.ErrInvalid}
	}
	if !fs.ValidPath(newname) || strings.Contains(newname, "\\") {
		return &fs.PathError{Op: "rename", Path: newname, Err: fs.ErrInvalid}
	}
	oldname = filepath.FromSlash(oldname)
	newname = filepath.FromSlash(newname)
	return os.Rename(filepath.Join(fsys.rootDir, oldname), filepath.Join(fsys.rootDir, newname))
}

type RemoteFS struct {
	ctx       context.Context
	db        *sql.DB
	dialect   string
	errorCode func(error) string
	storage   Storage
}

func NewRemoteFS(dialect string, db *sql.DB, errorCode func(error) string, storage Storage) *RemoteFS {
	return &RemoteFS{
		ctx:       context.Background(),
		db:        db,
		dialect:   dialect,
		errorCode: errorCode,
		storage:   storage,
	}
}

func (fsys *RemoteFS) WithContext(ctx context.Context) FS {
	return &RemoteFS{
		ctx:     ctx,
		db:      fsys.db,
		dialect: fsys.dialect,
		storage: fsys.storage,
	}
}

func (fsys *RemoteFS) Stat(name string) (fs.FileInfo, error) {
	err := fsys.ctx.Err()
	if err != nil {
		return nil, err
	}
	if !fs.ValidPath(name) || strings.Contains(name, "\\") {
		return nil, &fs.PathError{Op: "stat", Path: name, Err: fs.ErrInvalid}
	}
	if name == "." {
		return &RemoteFile{filePath: ".", isDir: true}, nil
	}
	file, err := sq.FetchOne(fsys.ctx, fsys.db, sq.Query{
		Dialect: fsys.dialect,
		Format:  "SELECT {*} FROM files WHERE file_path = {name}",
		Values: []any{
			sq.StringParam("name", name),
		},
	}, func(row *sq.Row) *RemoteFile {
		file := &RemoteFile{
			ctx: fsys.ctx,
		}
		row.UUID(&file.fileID, "file_id")
		row.UUID(&file.parentID, "parent_id")
		file.filePath = row.String("file_path")
		file.isDir = row.Bool("is_dir")
		file.numFiles = row.Int64("num_files")
		file.size = row.Int64("{}", sq.DialectExpression{
			Default: sq.Expr("SUM(COALESCE(OCTET_LENGTH(text), OCTET_LENGTH(data), size, 0))"),
			Cases: []sq.DialectCase{{
				Dialect: "sqlite",
				Result:  sq.Expr("SUM(COALESCE(LENGTH(CAST(text AS BLOB)), LENGTH(CAST(data AS BLOB)), size, 0))"),
			}},
		})
		file.modTime = row.Time("mod_time")
		return file
	})
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, &fs.PathError{Op: "stat", Path: name, Err: fs.ErrNotExist}
		}
		return nil, err
	}
	return file, nil
}

func (fsys *RemoteFS) Open(name string) (fs.File, error) {
	err := fsys.ctx.Err()
	if err != nil {
		return nil, err
	}
	if !fs.ValidPath(name) || strings.Contains(name, "\\") {
		return nil, &fs.PathError{Op: "open", Path: name, Err: fs.ErrInvalid}
	}
	if name == "." {
		return &RemoteFile{filePath: ".", isDir: true}, nil
	}
	file, err := sq.FetchOne(fsys.ctx, fsys.db, sq.Query{
		Dialect: fsys.dialect,
		Format:  "SELECT {*} FROM files WHERE file_path = {name}",
		Values: []any{
			sq.StringParam("name", name),
		},
	}, func(row *sq.Row) *RemoteFile {
		file := &RemoteFile{
			ctx:     fsys.ctx,
			storage: fsys.storage,
		}
		row.UUID(&file.fileID, "file_id")
		row.UUID(&file.parentID, "parent_id")
		file.filePath = row.String("file_path")
		file.isDir = row.Bool("is_dir")
		file.numFiles = row.Int64("num_files")
		file.size = row.Int64("{}", sq.DialectExpression{
			Default: sq.Expr("SUM(COALESCE(OCTET_LENGTH(text), OCTET_LENGTH(data), size, 0))"),
			Cases: []sq.DialectCase{{
				Dialect: "sqlite",
				Result:  sq.Expr("SUM(COALESCE(LENGTH(CAST(text AS BLOB)), LENGTH(CAST(data AS BLOB)), size, 0))"),
			}},
		})
		file.modTime = row.Time("mod_time")
		file.buf = getBuffer(row, "COALESCE(text, data)")
		return file
	})
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, &fs.PathError{Op: "open", Path: name, Err: fs.ErrNotExist}
		}
		return nil, err
	}
	return file, nil
}

func getBuffer(row *sq.Row, format string, values ...any) *bytes.Buffer {
	buf := bufPool.Get().(*bytes.Buffer)
	buf.Reset()
	b := buf.Bytes()
	row.Scan(&b, format, values...)
	if b == nil {
		bufPool.Put(buf)
		return nil
	}
	return bytes.NewBuffer(b)
}

type RemoteFile struct {
	ctx        context.Context
	storage    Storage
	fileID     [16]byte
	parentID   [16]byte
	filePath   string
	isDir      bool
	numFiles   int64
	size       int64
	modTime    time.Time
	buf        *bytes.Buffer
	readCloser io.ReadCloser
	numClones  *int
	mu         *sync.Mutex
}

func (file *RemoteFile) Read(p []byte) (n int, err error) {
	err = file.ctx.Err()
	if err != nil {
		return 0, err
	}
	if file.isDir {
		return 0, &fs.PathError{Op: "read", Path: file.filePath, Err: syscall.EISDIR}
	}
	if textExtensions[path.Ext(file.filePath)] {
		return file.buf.Read(p)
	}
	if file.readCloser == nil {
		file.readCloser, err = file.storage.Get(file.ctx, hex.EncodeToString(file.fileID[:])+path.Ext(file.filePath))
		if err != nil {
			return 0, err
		}
	}
	return file.readCloser.Read(p)
}

func (file *RemoteFile) Close() error {
	if file.isDir {
		return nil
	}
	if textExtensions[path.Ext(file.filePath)] {
		if file.buf == nil {
			return fs.ErrClosed
		}
		file.mu.Lock()
		if *file.numClones <= 0 {
			bufPool.Put(file.buf)
		} else {
			*file.numClones--
		}
		file.mu.Unlock()
		file.buf = nil
		return nil
	}
	if file.readCloser == nil {
		return fs.ErrClosed
	}
	err := file.readCloser.Close()
	if err != nil {
		return err
	}
	file.readCloser = nil
	return nil
}

func (file *RemoteFile) Clone() *RemoteFile {
	file.mu.Lock()
	clone := &RemoteFile{
		ctx:       file.ctx,
		storage:   file.storage,
		fileID:    file.fileID,
		parentID:  file.parentID,
		filePath:  file.filePath,
		isDir:     file.isDir,
		numFiles:  file.numFiles,
		size:      file.size,
		modTime:   file.modTime,
		buf:       bytes.NewBuffer(file.buf.Bytes()),
		numClones: file.numClones,
		mu:        file.mu,
	}
	*clone.numClones++
	file.mu.Unlock()
	return clone
}

func (file *RemoteFile) Name() string {
	return path.Base(file.filePath)
}

func (file *RemoteFile) Size() int64 {
	if textExtensions[path.Ext(file.filePath)] {
		return int64(file.buf.Len())
	}
	return file.size
}

func (file *RemoteFile) Mode() fs.FileMode {
	if file.isDir {
		return fs.ModeDir
	}
	return 0
}

func (file *RemoteFile) ModTime() time.Time { return file.modTime }

func (file *RemoteFile) IsDir() bool { return file.isDir }

func (file *RemoteFile) Sys() any { return file }

func (file *RemoteFile) Type() fs.FileMode { return file.Mode().Type() }

func (file *RemoteFile) Info() (fs.FileInfo, error) { return file, nil }

func (file *RemoteFile) Stat() (fs.FileInfo, error) { return file, nil }

func (fsys *RemoteFS) OpenWriter(name string, _ fs.FileMode) (io.WriteCloser, error) {
	err := fsys.ctx.Err()
	if err != nil {
		return nil, err
	}
	if !fs.ValidPath(name) || strings.Contains(name, "\\") {
		return nil, &fs.PathError{Op: "openwriter", Path: name, Err: fs.ErrInvalid}
	}
	if name == "." {
		return nil, &fs.PathError{Op: "openwriter", Path: name, Err: syscall.EISDIR}
	}
	file := &RemoteFileWriter{
		ctx:      fsys.ctx,
		db:       fsys.db,
		dialect:  fsys.dialect,
		storage:  fsys.storage,
		filePath: name,
		modTime:  time.Now().UTC().Truncate(time.Second),
	}
	parentDir := path.Dir(file.filePath)
	if parentDir == "." {
		// If parentDir is the root directory, just fetch the file information
		// (if it exists).
		result, err := sq.FetchOne(fsys.ctx, fsys.db, sq.Query{
			Dialect: fsys.dialect,
			Format:  "SELECT {*} FROM files WHERE file_path = {filePath}",
			Values: []any{
				sq.StringParam("filePath", file.filePath),
			},
		}, func(row *sq.Row) (result struct {
			fileID [16]byte
			isDir  bool
		}) {
			row.UUID(&result.fileID, "file_id")
			result.isDir = row.Bool("is_dir")
			return result
		})
		if err != nil {
			if !errors.Is(err, sql.ErrNoRows) {
				return nil, err
			}
		} else {
			if result.isDir {
				return nil, &fs.PathError{Op: "openwriter", Path: name, Err: syscall.EISDIR}
			}
			file.fileID = result.fileID
		}
	} else {
		results, err := sq.FetchAll(fsys.ctx, fsys.db, sq.Query{
			Dialect: fsys.dialect,
			Format:  "SELECT {*} FROM files WHERE file_path IN ({parentDir}, {filePath})",
			Values: []any{
				sq.StringParam("parentDir", parentDir),
				sq.StringParam("filePath", file.filePath),
			},
		}, func(row *sq.Row) (result struct {
			fileID   [16]byte
			filePath string
			isDir    bool
		}) {
			row.UUID(&result.fileID, "file_id")
			result.filePath = row.String("file_path")
			result.isDir = row.Bool("is_dir")
			return result
		})
		if err != nil {
			return nil, err
		}
		for _, result := range results {
			switch result.filePath {
			case name:
				if result.isDir {
					return nil, &fs.PathError{Op: "openwriter", Path: name, Err: syscall.EISDIR}
				}
				file.fileID = result.fileID
			case parentDir:
				if !result.isDir {
					return nil, &fs.PathError{Op: "openwriter", Path: name, Err: syscall.ENOTDIR}
				}
				file.parentID = result.fileID
			}
		}
		if file.parentID == nil {
			return nil, &fs.PathError{Op: "openwriter", Path: name, Err: fs.ErrNotExist}
		}
	}
	if textExtensions[path.Ext(file.filePath)] {
		file.buf = bufPool.Get().(*bytes.Buffer)
		file.buf.Reset()
	} else {
		pipeReader, pipeWriter := io.Pipe()
		file.storageWriter = pipeWriter
		file.storageResult = make(chan error, 1)
		go func() {
			file.storageResult <- fsys.storage.Put(file.ctx, hex.EncodeToString(file.fileID[:])+path.Ext(file.filePath), pipeReader)
			close(file.storageResult)
		}()
	}
	return file, nil
}

type RemoteFileWriter struct {
	ctx            context.Context
	db             *sql.DB
	dialect        string
	storage        Storage
	fileID         [16]byte
	parentID       any // either nil or [16]byte
	filePath       string
	buf            *bytes.Buffer
	modTime        time.Time
	storageWriter  *io.PipeWriter
	storageWritten int
	storageResult  chan error
	writeFailed    bool
}

func (file *RemoteFileWriter) Write(p []byte) (n int, err error) {
	err = file.ctx.Err()
	if err != nil {
		file.writeFailed = true
		return 0, err
	}
	if textExtensions[path.Ext(file.filePath)] {
		n, err = file.buf.Write(p)
		if err != nil {
			file.writeFailed = true
		}
		return n, err
	}
	n, err = file.storageWriter.Write(p)
	file.storageWritten += n
	if err != nil {
		file.writeFailed = true
	}
	return n, err
}

func (file *RemoteFileWriter) Close() error {
	if textExtensions[path.Ext(file.filePath)] {
		defer bufPool.Put(file.buf)
	} else {
		file.storageWriter.Close()
		err := <-file.storageResult
		if err != nil {
			return err
		}
	}
	if file.writeFailed {
		return nil
	}

	// If file exists, just have to update the file entry in the database.
	if file.fileID != [16]byte{} {
		if textExtensions[path.Ext(file.filePath)] {
			if isFulltextIndexed(file.filePath) {
				_, err := sq.Exec(file.ctx, file.db, sq.Query{
					Dialect: file.dialect,
					Format:  "UPDATE files SET text = {text}, data = NULL, size = NULL, mod_time = {modTime} WHERE file_id = {fileID}",
					Values: []any{
						sq.BytesParam("text", file.buf.Bytes()),
						sq.Param("modTime", sq.Timestamp{Time: file.modTime, Valid: true}),
						sq.UUIDParam("fileID", file.fileID),
					},
				})
				if err != nil {
					return err
				}
			} else {
				_, err := sq.Exec(file.ctx, file.db, sq.Query{
					Dialect: file.dialect,
					Format:  "UPDATE files SET text = NULL, data = {data}, size = NULL, mod_time = {modTime} WHERE file_id = {fileID}",
					Values: []any{
						sq.BytesParam("data", file.buf.Bytes()),
						sq.Param("modTime", sq.Timestamp{Time: file.modTime, Valid: true}),
						sq.UUIDParam("fileID", file.fileID),
					},
				})
				if err != nil {
					return err
				}
			}
		} else {
			_, err := sq.Exec(file.ctx, file.db, sq.Query{
				Dialect: file.dialect,
				Format:  "UPDATE files SET text = NULL, data = NULL, size = {size}, mod_time = {modTime} WHERE file_id = {fileID}",
				Values: []any{
					sq.IntParam("size", file.storageWritten),
					sq.Param("modTime", sq.Timestamp{Time: file.modTime, Valid: true}),
					sq.UUIDParam("fileID", file.fileID),
				},
			})
			if err != nil {
				return err
			}
		}
		return nil
	}

	// If we reach here it means file doesn't exist. Insert a new file entry
	// into the database.
	tx, err := file.db.BeginTx(file.ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	if textExtensions[path.Ext(file.filePath)] {
		if isFulltextIndexed(file.filePath) {
			_, err := sq.Exec(file.ctx, tx, sq.Query{
				Dialect: file.dialect,
				Format: "INSERT INTO files (file_id, parent_id, file_path, is_dir, text, mod_time)" +
					" VALUES ({fileID}, {parentID}, {filePath}, {isDir}, {text}, {modTime})",
				Values: []any{
					sq.UUIDParam("fileID", NewID()),
					sq.UUIDParam("parentID", file.parentID),
					sq.StringParam("filePath", file.filePath),
					sq.BoolParam("isDir", false),
					sq.BytesParam("text", file.buf.Bytes()),
					sq.Param("modTime", sq.Timestamp{Time: file.modTime, Valid: true}),
				},
			})
			if err != nil {
				return err
			}
		} else {
			_, err := sq.Exec(file.ctx, tx, sq.Query{
				Dialect: file.dialect,
				Format: "INSERT INTO files (file_id, parent_id, file_path, is_dir, data, mod_time)" +
					" VALUES ({fileID}, {parentID}, {filePath}, {isDir}, {data}, {modTime})",
				Values: []any{
					sq.UUIDParam("fileID", NewID()),
					sq.UUIDParam("parentID", file.parentID),
					sq.StringParam("filePath", file.filePath),
					sq.BoolParam("isDir", false),
					sq.BytesParam("data", file.buf.Bytes()),
					sq.Param("modTime", sq.Timestamp{Time: file.modTime, Valid: true}),
				},
			})
			if err != nil {
				return err
			}
		}
	} else {
		_, err := sq.Exec(file.ctx, tx, sq.Query{
			Dialect: file.dialect,
			Format: "INSERT INTO files (file_id, parent_id, file_path, is_dir, size, mod_time)" +
				" VALUES ({fileID}, {parentID}, {filePath}, {isDir}, {size}, {modTime})",
			Values: []any{
				sq.UUIDParam("fileID", NewID()),
				sq.UUIDParam("parentID", file.parentID),
				sq.StringParam("filePath", file.filePath),
				sq.BoolParam("isDir", false),
				sq.IntParam("size", file.storageWritten),
				sq.Param("modTime", sq.Timestamp{Time: file.modTime, Valid: true}),
			},
		})
		if err != nil {
			go file.storage.Delete(context.Background(), hex.EncodeToString(file.fileID[:])+path.Ext(file.filePath))
			return err
		}
	}
	if file.parentID != nil {
		_, err := sq.Exec(file.ctx, tx, sq.Query{
			Dialect: file.dialect,
			Format:  "UPDATE files SET num_files = num_files + 1 WHERE file_id = {parentID}",
			Values: []any{
				sq.UUIDParam("parentID", file.parentID),
			},
		})
		if err != nil {
			return err
		}
	}
	err = tx.Commit()
	if err != nil {
		return err
	}
	return nil
}

func (fsys *RemoteFS) Mkdir(dir string, _ fs.FileMode) error {
	err := fsys.ctx.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(dir) || strings.Contains(dir, "\\") {
		return &fs.PathError{Op: "mkdir", Path: dir, Err: fs.ErrInvalid}
	}
	if dir == "." {
		return nil
	}
	modTime := time.Now().UTC().Truncate(time.Second)
	parentDir := path.Dir(dir)
	if parentDir == "." {
		_, err := sq.Exec(fsys.ctx, fsys.db, sq.Query{
			Dialect: fsys.dialect,
			Format: "INSERT INTO files (file_id, file_path, is_dir, mod_time)" +
				" VALUES ({fileID}, {filePath}, {isDir}, {modTime})",
			Values: []any{
				sq.UUIDParam("fileID", NewID()),
				sq.StringParam("filePath", dir),
				sq.BoolParam("isDir", true),
				sq.Param("modTime", sq.Timestamp{Time: modTime, Valid: true}),
			},
		})
		if err != nil {
			if fsys.errorCode == nil {
				return err
			}
			errcode := fsys.errorCode(err)
			if IsKeyViolation(fsys.dialect, errcode) {
				return &fs.PathError{Op: "mkdir", Path: dir, Err: fs.ErrExist}
			}
			return err
		}
	} else {
		_, err = sq.Exec(fsys.ctx, fsys.db, sq.Query{
			Dialect: fsys.dialect,
			Format: "INSERT INTO files (file_id, parent_id, file_path, is_dir, mod_time)" +
				" VALUES ({fileID}, (select file_id FROM files WHERE file_path = {parentDir}), {filePath}, {isDir}, {modTime})",
			Values: []any{
				sq.UUIDParam("fileID", NewID()),
				sq.StringParam("parentDir", parentDir),
				sq.StringParam("filePath", dir),
				sq.BoolParam("isDir", true),
				sq.Param("modTime", sq.Timestamp{Time: modTime, Valid: true}),
			},
		})
		if err != nil {
			if fsys.errorCode == nil {
				return err
			}
			errcode := fsys.errorCode(err)
			if IsKeyViolation(fsys.dialect, errcode) {
				return &fs.PathError{Op: "mkdir", Path: dir, Err: fs.ErrExist}
			}
			return err
		}
	}
	return nil
}

func (fsys *RemoteFS) MkdirAll(dir string, _ fs.FileMode) error {
	err := fsys.ctx.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(dir) || strings.Contains(dir, "\\") {
		return &fs.PathError{Op: "mkdirall", Path: dir, Err: fs.ErrInvalid}
	}
	if dir == "." {
		return nil
	}
	tx, err := fsys.db.BeginTx(fsys.ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()

	// Insert the top level directory (no parent), ignoring duplicates.
	modTime := time.Now().UTC().Truncate(time.Second)
	segments := strings.Split(dir, "/")
	switch fsys.dialect {
	case "sqlite", "postgres":
		_, err := sq.Exec(fsys.ctx, tx, sq.Query{
			Dialect: fsys.dialect,
			Format: "INSERT INTO files (file_id, file_path, is_dir, mod_time)" +
				" VALUES ({fileID}, {filePath}, {isDir}, {modTime})" +
				" ON CONFLICT DO NOTHING",
			Values: []any{
				sq.UUIDParam("fileID", NewID()),
				sq.StringParam("filePath", segments[0]),
				sq.BoolParam("isDir", true),
				sq.Param("modTime", sq.Timestamp{Time: modTime, Valid: true}),
			},
		})
		if err != nil {
			return err
		}
	case "mysql":
		_, err := sq.Exec(fsys.ctx, tx, sq.Query{
			Dialect: fsys.dialect,
			Format: "INSERT INTO files (file_id, file_path, is_dir, mod_time)" +
				" VALUES ({fileID}, {filePath}, {isDir}, {modTime})" +
				" ON DUPLICATE KEY UPDATE file_id = file_id",
			Values: []any{
				sq.UUIDParam("fileID", NewID()),
				sq.StringParam("filePath", segments[0]),
				sq.BoolParam("isDir", true),
				sq.Param("modTime", sq.Timestamp{Time: modTime, Valid: true}),
			},
		})
		if err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported dialect %q", fsys.dialect)
	}

	// Insert the rest of the directories, ignoring duplicates.
	if len(segments) > 1 {
		var preparedExec *sq.PreparedExec
		switch fsys.dialect {
		case "sqlite", "postgres":
			preparedExec, err = sq.PrepareExec(fsys.ctx, tx, sq.Query{
				Dialect: fsys.dialect,
				Format: "INSERT INTO files (file_id, parent_id, file_path, is_dir, mod_time)" +
					" VALUES ({fileID}, (select file_id FROM files WHERE file_path = {parentDir}), {filePath}, {isDir}, {modTime})" +
					" ON CONFLICT DO NOTHING",
				Values: []any{
					sq.Param("fileID", nil),
					sq.Param("parentDir", nil),
					sq.Param("filePath", nil),
					sq.Param("isDir", nil),
					sq.Param("modTime", nil),
				},
			})
			if err != nil {
				return err
			}
		case "mysql":
			preparedExec, err = sq.PrepareExec(fsys.ctx, tx, sq.Query{
				Dialect: fsys.dialect,
				Format: "INSERT INTO files (file_id, parent_id, file_path, is_dir, mod_time)" +
					" VALUES ({fileID}, (select file_id FROM files WHERE file_path = {parentDir}), {filePath}, {isDir}, {modTime})" +
					" ON DUPLICATE KEY UPDATE file_id = file_id",
				Values: []any{
					sq.Param("fileID", nil),
					sq.Param("parentDir", nil),
					sq.Param("filePath", nil),
					sq.Param("isDir", nil),
					sq.Param("modTime", nil),
				},
			})
			if err != nil {
				return err
			}
		default:
			return fmt.Errorf("unsupported dialect %q", fsys.dialect)
		}
		defer preparedExec.Close()
		for i := 1; i < len(segments); i++ {
			parentDir := path.Join(segments[:i]...)
			filePath := path.Join(segments[:i+1]...)
			_, err := preparedExec.Exec(fsys.ctx,
				sq.UUIDParam("fileID", NewID()),
				sq.StringParam("parentDir", parentDir),
				sq.StringParam("filePath", filePath),
				sq.BoolParam("isDir", true),
				sq.Param("modTime", sq.Timestamp{Time: modTime, Valid: true}),
			)
			if err != nil {
				return err
			}
		}
		err = preparedExec.Close()
		if err != nil {
			return err
		}
	}
	err = tx.Commit()
	if err != nil {
		return err
	}
	return nil
}

func (fsys *RemoteFS) ScanDirFiles(dir string, fn func(fs.File) error) error {
	if dir == "." {
		cursor, err := sq.FetchCursor(fsys.ctx, fsys.db, sq.Query{
			Dialect: fsys.dialect,
			Format:  "SELECT {*} FROM files WHERE parent_id IS NULL",
		}, func(row *sq.Row) *RemoteFile {
			file := &RemoteFile{
				ctx:     fsys.ctx,
				storage: fsys.storage,
			}
			row.UUID(&file.fileID, "file_id")
			file.filePath = row.String("file_path")
			file.isDir = row.Bool("is_dir")
			file.numFiles = row.Int64("num_files")
			file.size = row.Int64("{}", sq.DialectExpression{
				Default: sq.Expr("SUM(COALESCE(OCTET_LENGTH(text), OCTET_LENGTH(data), size, 0))"),
				Cases: []sq.DialectCase{{
					Dialect: "sqlite",
					Result:  sq.Expr("SUM(COALESCE(LENGTH(CAST(text AS BLOB)), LENGTH(CAST(data AS BLOB)), size, 0))"),
				}},
			})
			file.modTime = row.Time("mod_time")
			file.buf = getBuffer(row, "COALESCE(text, data)")
			return file
		})
		if err != nil {
			return err
		}
		defer cursor.Close()
		for cursor.Next() {
			file, err := cursor.Result()
			if err != nil {
				return err
			}
			err = fn(file)
			if err != nil {
				if err == fs.SkipAll || err == fs.SkipDir {
					return nil
				}
				return err
			}
		}
		return cursor.Close()
	}

	cursor, err := sq.FetchCursor(fsys.ctx, fsys.db, sq.Query{
		Dialect: fsys.dialect,
		Format:  "SELECT {*} FROM files WHERE parent_id = (SELECT file_id FROM files WHERE file_path = {dir})",
		Values: []any{
			sq.StringParam("dir", dir),
		},
	}, func(row *sq.Row) *RemoteFile {
		file := &RemoteFile{
			ctx:     fsys.ctx,
			storage: fsys.storage,
		}
		row.UUID(&file.fileID, "file_id")
		file.filePath = row.String("file_path")
		file.isDir = row.Bool("is_dir")
		file.numFiles = row.Int64("num_files")
		file.size = row.Int64("{}", sq.DialectExpression{
			Default: sq.Expr("SUM(COALESCE(OCTET_LENGTH(text), OCTET_LENGTH(data), size, 0))"),
			Cases: []sq.DialectCase{{
				Dialect: "sqlite",
				Result:  sq.Expr("SUM(COALESCE(LENGTH(CAST(text AS BLOB)), LENGTH(CAST(data AS BLOB)), size, 0))"),
			}},
		})
		file.modTime = row.Time("mod_time")
		file.buf = getBuffer(row, "COALESCE(text, data)")
		return file
	})
	if err != nil {
		return err
	}
	defer cursor.Close()
	for cursor.Next() {
		file, err := cursor.Result()
		if err != nil {
			return err
		}
		err = fn(file)
		if err != nil {
			if err == fs.SkipAll || err == fs.SkipDir {
				return nil
			}
			return err
		}
	}
	return cursor.Close()
}

func (fsys *RemoteFS) ScanDir(dir string, fn func(fs.DirEntry) error) error {
	err := fsys.ctx.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(dir) || strings.Contains(dir, "\\") {
		return &fs.PathError{Op: "scandir", Path: dir, Err: fs.ErrInvalid}
	}
	return fsys.scanDir(dir, fn, sq.Expr(""), sq.Expr("ORDER BY file_path"), sq.Expr(""))
}

func (fsys *RemoteFS) ScanDirAfterName(dir string, fn func(fs.DirEntry) error, name string, limit int) error {
	err := fsys.ctx.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(dir) || strings.Contains(dir, "\\") {
		return &fs.PathError{Op: "scandiraftername", Path: dir, Err: fs.ErrInvalid}
	}
	return fsys.scanDir(dir, fn, sq.Expr("AND file_path >= {}", path.Join(dir, name)), sq.Expr("ORDER BY file_path"), sq.Expr("LIMIT {}", limit))
}

func (fsys *RemoteFS) ScanDirBeforeName(dir string, fn func(fs.DirEntry) error, name string, limit int) error {
	err := fsys.ctx.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(dir) || strings.Contains(dir, "\\") {
		return &fs.PathError{Op: "scandirbeforename", Path: dir, Err: fs.ErrInvalid}
	}
	return fsys.scanDir(dir, fn, sq.Expr("AND file_path <= {}", path.Join(dir, name)), sq.Expr("ORDER BY file_path DESC"), sq.Expr("LIMIT {}", limit))
}

func (fsys *RemoteFS) ScanDirAfterModTime(dir string, fn func(fs.DirEntry) error, modTime time.Time, limit int) error {
	err := fsys.ctx.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(dir) || strings.Contains(dir, "\\") {
		return &fs.PathError{Op: "scandiraftermodtime", Path: dir, Err: fs.ErrInvalid}
	}
	return fsys.scanDir(dir, fn, sq.Expr("AND mod_time >= {}", modTime), sq.Expr("ORDER BY mod_time"), sq.Expr("LIMIT {}", limit))
}

func (fsys *RemoteFS) ScanDirBeforeModTime(dir string, fn func(fs.DirEntry) error, modTime time.Time, limit int) error {
	err := fsys.ctx.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(dir) || strings.Contains(dir, "\\") {
		return &fs.PathError{Op: "scandirbeforemodtime", Path: dir, Err: fs.ErrInvalid}
	}
	return fsys.scanDir(dir, fn, sq.Expr("AND mod_time <= {}", modTime), sq.Expr("ORDER BY mod_time DESC"), sq.Expr("LIMIT {}", limit))
}

func (fsys *RemoteFS) scanDir(dir string, fn func(fs.DirEntry) error, condition, order, limit sq.Expression) error {
	if dir == "." {
		cursor, err := sq.FetchCursor(fsys.ctx, fsys.db, sq.Query{
			Dialect: fsys.dialect,
			Format:  "SELECT {*} FROM files WHERE parent_id IS NULL {condition} {order} {limit}",
			Values: []any{
				sq.Param("condition", condition),
				sq.Param("order", order),
				sq.Param("limit", limit),
			},
		}, func(row *sq.Row) *RemoteFile {
			file := &RemoteFile{
				ctx:     fsys.ctx,
				storage: fsys.storage,
			}
			row.UUID(&file.fileID, "file_id")
			file.filePath = row.String("file_path")
			file.isDir = row.Bool("is_dir")
			file.numFiles = row.Int64("num_files")
			file.size = row.Int64("{}", sq.DialectExpression{
				Default: sq.Expr("SUM(COALESCE(OCTET_LENGTH(text), OCTET_LENGTH(data), size, 0))"),
				Cases: []sq.DialectCase{{
					Dialect: "sqlite",
					Result:  sq.Expr("SUM(COALESCE(LENGTH(CAST(text AS BLOB)), LENGTH(CAST(data AS BLOB)), size, 0))"),
				}},
			})
			file.modTime = row.Time("mod_time")
			file.buf = getBuffer(row, "COALESCE(text, data)")
			return file
		})
		if err != nil {
			return err
		}
		defer cursor.Close()
		for cursor.Next() {
			file, err := cursor.Result()
			if err != nil {
				return err
			}
			err = fn(file)
			if err != nil {
				if err == fs.SkipAll || err == fs.SkipDir {
					return nil
				}
				return err
			}
		}
		return cursor.Close()
	}

	cursor, err := sq.FetchCursor(fsys.ctx, fsys.db, sq.Query{
		Dialect: fsys.dialect,
		Format:  "SELECT {*} FROM files WHERE parent_id = (SELECT file_id FROM files WHERE file_path = {dir}) {condition} {order} {limit}",
		Values: []any{
			sq.StringParam("dir", dir),
			sq.Param("condition", condition),
			sq.Param("order", order),
			sq.Param("limit", limit),
		},
	}, func(row *sq.Row) *RemoteFile {
		file := &RemoteFile{
			ctx:     fsys.ctx,
			storage: fsys.storage,
		}
		row.UUID(&file.fileID, "file_id")
		file.filePath = row.String("file_path")
		file.isDir = row.Bool("is_dir")
		file.numFiles = row.Int64("num_files")
		file.size = row.Int64("{}", sq.DialectExpression{
			Default: sq.Expr("SUM(COALESCE(OCTET_LENGTH(text), OCTET_LENGTH(data), size, 0))"),
			Cases: []sq.DialectCase{{
				Dialect: "sqlite",
				Result:  sq.Expr("SUM(COALESCE(LENGTH(CAST(text AS BLOB)), LENGTH(CAST(data AS BLOB)), size, 0))"),
			}},
		})
		file.modTime = row.Time("mod_time")
		file.buf = getBuffer(row, "COALESCE(text, data)")
		return file
	})
	if err != nil {
		return err
	}
	defer cursor.Close()
	for cursor.Next() {
		file, err := cursor.Result()
		if err != nil {
			return err
		}
		err = fn(file)
		if err != nil {
			if err == fs.SkipAll || err == fs.SkipDir {
				return nil
			}
			return err
		}
	}
	return cursor.Close()
}

func (fsys *RemoteFS) WalkDirFiles(dir string, fn func(filePath string, file fs.File, err error) error) error {
	err := fsys.ctx.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(dir) || strings.Contains(dir, "\\") {
		return &fs.PathError{Op: "walkdirfiles", Path: dir, Err: fs.ErrInvalid}
	}

	if dir == "." {
		err = fn(".", &RemoteFile{ctx: fsys.ctx, filePath: ".", isDir: true}, nil)
		if err != nil {
			if err == fs.SkipDir || err == fs.SkipAll {
				return nil
			}
			return err
		}
		cursor, err := sq.FetchCursor(fsys.ctx, fsys.db, sq.Query{
			Dialect: fsys.dialect,
			Format:  "SELECT {*} FROM files ORDER BY file_path",
		}, func(row *sq.Row) *RemoteFile {
			file := &RemoteFile{
				ctx:       fsys.ctx,
				storage:   fsys.storage,
				numClones: new(int),
				mu:        &sync.Mutex{},
			}
			row.UUID(&file.fileID, "file_id")
			row.UUID(&file.parentID, "parent_id")
			file.filePath = row.String("file_path")
			file.isDir = row.Bool("is_dir")
			file.numFiles = row.Int64("num_files")
			file.size = row.Int64("{}", sq.DialectExpression{
				Default: sq.Expr("SUM(COALESCE(OCTET_LENGTH(text), OCTET_LENGTH(data), size, 0))"),
				Cases: []sq.DialectCase{{
					Dialect: "sqlite",
					Result:  sq.Expr("SUM(COALESCE(LENGTH(CAST(text AS BLOB)), LENGTH(CAST(data AS BLOB)), size, 0))"),
				}},
			})
			file.modTime = row.Time("mod_time")
			file.buf = getBuffer(row, "COALESCE(text, data)")
			return file
		})
		if err != nil {
			return err
		}
		defer cursor.Close()
		var skipDir string
		for cursor.Next() {
			file, err := cursor.Result()
			if err != nil {
				return err
			}
			if skipDir != "" && strings.HasPrefix(file.filePath, skipDir) {
				continue
			}
			err = fn(file.filePath, file, nil)
			if err != nil {
				if err == fs.SkipAll {
					return nil
				}
				if err == fs.SkipDir {
					if file.isDir {
						skipDir = file.filePath + "/"
					} else {
						skipDir = path.Dir(file.filePath) + "/"
					}
					continue
				}
				return err
			}
		}
		return cursor.Close()
	}

	cursor, err := sq.FetchCursor(fsys.ctx, fsys.db, sq.Query{
		Dialect: fsys.dialect,
		Format:  "SELECT {*} FROM files WHERE file_path = {root} OR file_path LIKE {pattern} ESCAPE '\\' ORDER BY file_path",
		Values: []any{
			sq.StringParam("root", dir),
			sq.StringParam("pattern", strings.NewReplacer("%", "\\%", "_", "\\_").Replace(dir)+"/%"),
		},
	}, func(row *sq.Row) *RemoteFile {
		file := &RemoteFile{
			ctx:       fsys.ctx,
			storage:   fsys.storage,
			numClones: new(int),
			mu:        &sync.Mutex{},
		}
		row.UUID(&file.fileID, "file_id")
		row.UUID(&file.parentID, "parent_id")
		file.filePath = row.String("file_path")
		file.isDir = row.Bool("is_dir")
		file.numFiles = row.Int64("num_files")
		file.size = row.Int64("{}", sq.DialectExpression{
			Default: sq.Expr("SUM(COALESCE(OCTET_LENGTH(text), OCTET_LENGTH(data), size, 0))"),
			Cases: []sq.DialectCase{{
				Dialect: "sqlite",
				Result:  sq.Expr("SUM(COALESCE(LENGTH(CAST(text AS BLOB)), LENGTH(CAST(data AS BLOB)), size, 0))"),
			}},
		})
		file.modTime = row.Time("mod_time")
		file.buf = getBuffer(row, "COALESCE(text, data)")
		return file
	})
	if err != nil {
		return err
	}
	defer cursor.Close()
	var skipDir string
	for cursor.Next() {
		file, err := cursor.Result()
		if err != nil {
			return err
		}
		if file.isDir && skipDir != "" && (file.filePath == strings.TrimSuffix(skipDir, "/") || strings.HasPrefix(file.filePath, skipDir)) {
			continue
		}
		err = fn(file.filePath, file, nil)
		if err != nil {
			if err == fs.SkipAll {
				return nil
			}
			if err == fs.SkipDir {
				if file.isDir {
					skipDir = file.filePath + "/"
				} else {
					skipDir = path.Dir(file.filePath) + "/"
				}
				continue
			}
			return err
		}
	}
	return cursor.Close()
}

func (fsys *RemoteFS) Remove(name string) error {
	err := fsys.ctx.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(name) || strings.Contains(name, "\\") || name == "." {
		return &fs.PathError{Op: "remove", Path: name, Err: fs.ErrInvalid}
	}
	file, err := sq.FetchOne(fsys.ctx, fsys.db, sq.Query{
		Dialect: fsys.dialect,
		Format:  "SELECT {*} FROM files WHERE file_path = {name}",
		Values: []any{
			sq.StringParam("name", name),
		},
	}, func(row *sq.Row) (file struct {
		fileID       [16]byte
		filePath     string
		isDir        bool
		isStoredInDB bool
		hasChildren  bool
	}) {
		row.UUID(&file.fileID, "file_id")
		file.filePath = row.String("file_path")
		file.isDir = row.Bool("is_dir")
		file.isStoredInDB = row.Bool("text IS NOT NULL OR data IS NOT NULL")
		file.hasChildren = row.Bool("EXISTS (SELECT 1 FROM files WHERE file_path LIKE {pattern} ESCAPE '\\')", sq.StringParam("pattern", strings.NewReplacer("%", "\\%", "_", "\\_").Replace(name)+"/%"))
		return file
	})
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return &fs.PathError{Op: "remove", Path: name, Err: fs.ErrNotExist}
		}
		return err
	}
	if file.hasChildren {
		return &fs.PathError{Op: "remove", Path: name, Err: syscall.ENOTEMPTY}
	}
	if !file.isStoredInDB {
		err = fsys.storage.Delete(fsys.ctx, hex.EncodeToString(file.fileID[:])+path.Ext(file.filePath))
		if err != nil {
			return err
		}
	}
	tx, err := fsys.db.BeginTx(fsys.ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	// NOTE: For SQLite and Postgres, we can reduce the number of queries to 2
	// (current is 3) by using DELETE ... RETURNING. Do this if Remove() proves
	// to be too slow.
	_, err = sq.Exec(fsys.ctx, tx, sq.Query{
		Dialect: fsys.dialect,
		Format:  "DELETE FROM files WHERE file_path = {name}",
		Values: []any{
			sq.StringParam("name", name),
		},
	})
	if err != nil {
		return err
	}
	if !file.isDir {
		parentDir := path.Dir(name)
		if parentDir != "." {
			_, err = sq.Exec(fsys.ctx, tx, sq.Query{
				Dialect: fsys.dialect,
				Format:  "UPDATE files SET num_files = num_files - 1 WHERE file_path = {parentDir} AND num_files > 0",
				Values: []any{
					sq.StringParam("parentDir", parentDir),
				},
			})
			if err != nil {
				return err
			}
		}
	}
	err = tx.Commit()
	if err != nil {
		return err
	}
	return nil
}

func (fsys *RemoteFS) RemoveAll(name string) error {
	err := fsys.ctx.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(name) || strings.Contains(name, "\\") || name == "." {
		return &fs.PathError{Op: "removeall", Path: name, Err: fs.ErrInvalid}
	}
	pattern := strings.NewReplacer("%", "\\%", "_", "\\_").Replace(name) + "/%"
	files, err := sq.FetchAll(fsys.ctx, fsys.db, sq.Query{
		Dialect: fsys.dialect,
		Format:  "SELECT {*} FROM files WHERE (file_path = {name} OR file_path LIKE {pattern} ESCAPE '\\') AND text IS NULL AND data IS NULL",
		Values: []any{
			sq.StringParam("name", name),
			sq.StringParam("pattern", pattern),
		},
	}, func(row *sq.Row) (file struct {
		fileID   [16]byte
		filePath string
	}) {
		row.UUID(&file.fileID, "file_id")
		file.filePath = row.String("file_path")
		return file
	})
	g, ctx := errgroup.WithContext(fsys.ctx)
	for _, file := range files {
		file := file
		g.Go(func() error {
			return fsys.storage.Delete(ctx, hex.EncodeToString(file.fileID[:])+path.Ext(file.filePath))
		})
	}
	err = g.Wait()
	if err != nil {
		return err
	}
	tx, err := fsys.db.BeginTx(fsys.ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	_, err = sq.Exec(fsys.ctx, tx, sq.Query{
		Dialect: fsys.dialect,
		Format:  "DELETE FROM files WHERE file_path LIKE {pattern} ESCAPE '\\'",
		Values: []any{
			sq.StringParam("pattern", pattern),
		},
	})
	if err != nil {
		return err
	}
	isDir, err := sq.FetchOne(fsys.ctx, tx, sq.Query{
		Dialect: fsys.dialect,
		Format:  "SELECT {*} FROM files WHERE file_path = {name}",
		Values: []any{
			sq.StringParam("name", name),
		},
	}, func(row *sq.Row) bool {
		return row.Bool("is_dir")
	})
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}
		return err
	}
	// NOTE: For SQLite and Postgres, we can reduce the number of queries to 2
	// (current is 5) by using DELETE ... RETURNING. Do this if RemoveAll()
	// proves to be too slow.
	_, err = sq.Exec(fsys.ctx, tx, sq.Query{
		Dialect: fsys.dialect,
		Format:  "DELETE FROM files WHERE file_path = {name}",
		Values: []any{
			sq.StringParam("name", name),
		},
	})
	if err != nil {
		return err
	}
	if !isDir {
		parentDir := path.Dir(name)
		if parentDir != "." {
			_, err = sq.Exec(fsys.ctx, tx, sq.Query{
				Dialect: fsys.dialect,
				Format:  "UPDATE files SET num_files = num_files - 1 WHERE file_path = {parentDir} AND num_files > 0",
				Values: []any{
					sq.StringParam("parentDir", parentDir),
				},
			})
			if err != nil {
				return err
			}
		}
	}
	err = tx.Commit()
	if err != nil {
		return err
	}
	return nil
}

func (fsys *RemoteFS) Rename(oldname, newname string) error {
	err := fsys.ctx.Err()
	if err != nil {
		return err
	}
	if !fs.ValidPath(oldname) || strings.Contains(oldname, "\\") {
		return &fs.PathError{Op: "rename", Path: oldname, Err: fs.ErrInvalid}
	}
	if !fs.ValidPath(newname) || strings.Contains(newname, "\\") {
		return &fs.PathError{Op: "rename", Path: newname, Err: fs.ErrInvalid}
	}
	modTime := sq.Timestamp{
		Time:  time.Now().UTC().Truncate(time.Second),
		Valid: true,
	}
	tx, err := fsys.db.BeginTx(fsys.ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	oldnameIsDir, err := sq.FetchOne(fsys.ctx, tx, sq.Query{
		Dialect: fsys.dialect,
		Format:  "SELECT {*} FROM files WHERE file_path = {oldname}",
		Values: []any{
			sq.StringParam("oldname", oldname),
		},
	}, func(row *sq.Row) bool {
		return row.Bool("is_dir")
	})
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return &fs.PathError{Op: "rename", Path: oldname, Err: fs.ErrNotExist}
		}
		return err
	}
	if !oldnameIsDir && textExtensions[path.Ext(oldname)] != textExtensions[path.Ext(newname)] {
		return fmt.Errorf("cannot rename file from %q to %q because their extensions are not compatible", oldname, newname)
	}
	_, err = sq.Exec(fsys.ctx, tx, sq.Query{
		Dialect: fsys.dialect,
		Format:  "DELETE FROM files WHERE file_path = {newname} AND NOT is_dir",
		Values: []any{
			sq.StringParam("newname", newname),
		},
	})
	if err != nil {
		return err
	}
	updateTextOrData := sq.Expr("")
	if !oldnameIsDir && textExtensions[path.Ext(oldname)] && textExtensions[path.Ext(newname)] {
		if !isFulltextIndexed(oldname) && isFulltextIndexed(newname) {
			switch fsys.dialect {
			case "sqlite":
				updateTextOrData = sq.Expr(", text = data, data = NULL")
			case "postgres":
				updateTextOrData = sq.Expr(", text = convert_from(data, 'UTF8'), data = NULL")
			case "mysql":
				updateTextOrData = sq.Expr(", text = convert(data USING utf8mb4), data = NULL")
			}
		} else if isFulltextIndexed(oldname) && !isFulltextIndexed(newname) {
			switch fsys.dialect {
			case "sqlite":
				updateTextOrData = sq.Expr(", data = text, text = NULL")
			case "postgres":
				updateTextOrData = sq.Expr(", data = convert_to(text, 'UTF8'), text = NULL")
			case "mysql":
				updateTextOrData = sq.Expr(", data = convert(text USING BINARY), text = NULL")
			}
		}
	}
	_, err = sq.Exec(fsys.ctx, tx, sq.Query{
		Dialect: fsys.dialect,
		Format:  "UPDATE files SET file_path = {newname}, mod_time = {modTime} {updateTextOrData} WHERE file_path = {oldname}",
		Values: []any{
			sq.StringParam("newname", newname),
			sq.Param("modTime", modTime),
			sq.Param("updateTextOrData", updateTextOrData),
			sq.StringParam("oldname", oldname),
		},
	})
	if err != nil {
		// We weren't able to delete {newname} earlier, which means it is a
		// directory.
		if fsys.errorCode == nil {
			return err
		}
		errcode := fsys.errorCode(err)
		if IsKeyViolation(fsys.dialect, errcode) {
			return &fs.PathError{Op: "rename", Path: newname, Err: syscall.EISDIR}
		}
		return err
	}
	if oldnameIsDir {
		_, err = sq.Exec(fsys.ctx, tx, sq.Query{
			Dialect: fsys.dialect,
			Format:  "UPDATE files SET file_path = {newFilePath}, mod_time = {modTime} WHERE file_path LIKE {pattern} ESCAPE '\\'",
			Values: []any{
				sq.Param("newFilePath", sq.DialectExpression{
					Default: sq.Expr("{} || SUBSTR(file_path, {})", newname, len(oldname)+1),
					Cases: []sq.DialectCase{{
						Dialect: "mysql",
						Result:  sq.Expr("CONCAT({}, SUBSTR(file_path, {}))", newname, len(oldname)+1),
					}},
				}),
				sq.Param("modTime", modTime),
				sq.StringParam("pattern", strings.NewReplacer("%", "\\%", "_", "\\_").Replace(oldname)+"/%"),
			},
		})
		if err != nil {
			return err
		}
	}
	err = tx.Commit()
	if err != nil {
		return err
	}
	return nil
}

type Storage interface {
	Get(ctx context.Context, key string) (io.ReadCloser, error)
	Put(ctx context.Context, key string, reader io.Reader) error
	Delete(ctx context.Context, key string) error
}

type S3Storage struct {
	Client *s3.Client
	Bucket string
}

var _ Storage = (*S3Storage)(nil)

type S3StorageConfig struct {
	Endpoint        string `json:"endpoint,omitempty"`
	Region          string `json:"region,omitempty"`
	Bucket          string `json:"bucket,omitempty"`
	AccessKeyID     string `json:"accessKeyID,omitempty"`
	SecretAccessKey string `json:"secretAccessKey,omitempty"`
}

func NewS3Storage(ctx context.Context, config S3StorageConfig) (*S3Storage, error) {
	storage := &S3Storage{
		Client: s3.New(s3.Options{
			BaseEndpoint: aws.String(config.Endpoint),
			Region:       config.Region,
			Credentials:  aws.NewCredentialsCache(credentials.NewStaticCredentialsProvider(config.AccessKeyID, config.SecretAccessKey, "")),
		}),
		Bucket: config.Bucket,
	}
	// Ping the bucket and see if we have access.
	_, err := storage.Client.ListObjectsV2(ctx, &s3.ListObjectsV2Input{
		Bucket:  &storage.Bucket,
		MaxKeys: aws.Int32(1),
	})
	if err != nil {
		return nil, err
	}
	return storage, nil
}

func (storage *S3Storage) Get(ctx context.Context, key string) (io.ReadCloser, error) {
	output, err := storage.Client.GetObject(ctx, &s3.GetObjectInput{
		Bucket: &storage.Bucket,
		Key:    aws.String(key),
	})
	if err != nil {
		var apiErr smithy.APIError
		if errors.As(err, &apiErr) {
			if apiErr.ErrorCode() == "NoSuchKey" {
				return nil, &fs.PathError{Op: "get", Path: key, Err: fs.ErrNotExist}
			}
		}
		return nil, err
	}
	return output.Body, nil
}

func (storage *S3Storage) Put(ctx context.Context, key string, reader io.Reader) error {
	_, err := storage.Client.PutObject(ctx, &s3.PutObjectInput{
		Bucket: &storage.Bucket,
		Key:    aws.String(key),
		Body:   reader,
	})
	if err != nil {
		return err
	}
	return nil
}

func (storage *S3Storage) Delete(ctx context.Context, key string) error {
	_, err := storage.Client.DeleteObject(ctx, &s3.DeleteObjectInput{
		Bucket: &storage.Bucket,
		Key:    aws.String(key),
	})
	if err != nil {
		return err
	}
	return nil
}

type InMemoryStorage struct {
	mu      sync.RWMutex
	entries map[string][]byte
}

var _ Storage = (*InMemoryStorage)(nil)

func NewInMemoryStorage() *InMemoryStorage {
	return &InMemoryStorage{
		mu:      sync.RWMutex{},
		entries: make(map[string][]byte),
	}
}

func (storage *InMemoryStorage) Get(ctx context.Context, key string) (io.ReadCloser, error) {
	storage.mu.RLock()
	value, ok := storage.entries[key]
	storage.mu.RUnlock()
	if !ok {
		return nil, &fs.PathError{Op: "get", Path: key, Err: fs.ErrNotExist}
	}
	return io.NopCloser(bytes.NewReader(value)), nil
}

func (storage *InMemoryStorage) Put(ctx context.Context, key string, reader io.Reader) error {
	value, err := io.ReadAll(reader)
	if err != nil {
		return err
	}
	storage.mu.Lock()
	storage.entries[key] = value
	storage.mu.Unlock()
	return nil
}

func (storage *InMemoryStorage) Delete(ctx context.Context, key string) error {
	storage.mu.Lock()
	delete(storage.entries, key)
	storage.mu.Unlock()
	return nil
}

type FileStorage struct {
	rootDir string
	tempDir string
}

func NewFileStorage(rootDir, tempDir string) *FileStorage {
	return &FileStorage{
		rootDir: filepath.FromSlash(rootDir),
		tempDir: filepath.FromSlash(tempDir),
	}
}

func (storage *FileStorage) Get(ctx context.Context, key string) (io.ReadCloser, error) {
	err := ctx.Err()
	if err != nil {
		return nil, err
	}
	if len(key) < 4 {
		return nil, &fs.PathError{Op: "get", Path: key, Err: fs.ErrInvalid}
	}
	file, err := os.Open(filepath.Join(storage.rootDir, key[:4], key))
	if err != nil {
		if errors.Is(err, fs.ErrNotExist) {
			return nil, &fs.PathError{Op: "get", Path: key, Err: fs.ErrNotExist}
		}
		return nil, err
	}
	return file, nil
}

func (storage *FileStorage) Put(ctx context.Context, key string, reader io.Reader) error {
	err := ctx.Err()
	if err != nil {
		return err
	}
	if len(key) < 4 {
		return &fs.PathError{Op: "put", Path: key, Err: fs.ErrInvalid}
	}
	if runtime.GOOS == "windows" {
		file, err := os.OpenFile(filepath.Join(storage.rootDir, key[:4], key), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
		if err != nil {
			return err
		}
		_, err = io.Copy(file, reader)
		if err != nil {
			return err
		}
		return nil
	}
	tempDir := storage.tempDir
	if tempDir == "" {
		tempDir = os.TempDir()
	}
	tempFile, err := os.CreateTemp(tempDir, "__notebrewtemp*__")
	if err != nil {
		return err
	}
	fileInfo, err := tempFile.Stat()
	if err != nil {
		return err
	}
	tempFilePath := filepath.Join(tempDir, fileInfo.Name())
	destFilePath := filepath.Join(storage.rootDir, key[:4], key)
	defer os.Remove(tempFilePath)
	defer tempFile.Close()
	_, err = io.Copy(tempFile, reader)
	if err != nil {
		return err
	}
	err = tempFile.Close()
	if err != nil {
		return err
	}
	err = os.Rename(tempFilePath, destFilePath)
	if err != nil {
		if !errors.Is(err, fs.ErrNotExist) {
			return err
		}
		err := os.Mkdir(filepath.Join(storage.rootDir, key[:4]), 0755)
		if err != nil && !errors.Is(err, fs.ErrExist) {
			return err
		}
		err = os.Rename(tempFilePath, destFilePath)
		if err != nil {
			return err
		}
	}
	return nil
}

func (storage *FileStorage) Delete(ctx context.Context, key string) error {
	err := ctx.Err()
	if err != nil {
		return err
	}
	if len(key) < 4 {
		return &fs.PathError{Op: "delete", Path: key, Err: fs.ErrInvalid}
	}
	err = os.Remove(filepath.Join(storage.rootDir, key[:4], key))
	if err != nil {
		return err
	}
	return nil
}

func NewID() [16]byte {
	var timestamp [8]byte
	binary.BigEndian.PutUint64(timestamp[:], uint64(time.Now().Unix()))
	var id [16]byte
	copy(id[:5], timestamp[len(timestamp)-5:])
	_, err := rand.Read(id[5:])
	if err != nil {
		panic(err)
	}
	return id
}

func IsKeyViolation(dialect string, errcode string) bool {
	switch dialect {
	case "sqlite":
		return errcode == "1555" || errcode == "2067" // SQLITE_CONSTRAINT_PRIMARYKEY, SQLITE_CONSTRAINT_UNIQUE
	case "postgres":
		return errcode == "23505" // unique_violation
	case "mysql":
		return errcode == "1062" // ER_DUP_ENTRY
	case "sqlserver":
		return errcode == "2627"
	default:
		return false
	}
}

func IsForeignKeyViolation(dialect string, errcode string) bool {
	switch dialect {
	case "sqlite":
		return errcode == "787" //  SQLITE_CONSTRAINT_FOREIGNKEY
	case "postgres":
		return errcode == "23503" // foreign_key_violation
	case "mysql":
		return errcode == "1216" // ER_NO_REFERENCED_ROW
	case "sqlserver":
		return errcode == "547"
	default:
		return false
	}
}

var textExtensions = map[string]bool{
	".html": true,
	".css":  true,
	".js":   true,
	".md":   true,
	".txt":  true,
	".json": true,
	".xml":  true,
}

func isFulltextIndexed(filePath string) bool {
	ext := path.Ext(filePath)
	head, tail, _ := strings.Cut(filePath, "/")
	switch head {
	case "notes":
		return ext == ".html" || ext == ".css" || ext == ".js" || ext == ".md" || ext == ".txt"
	case "pages":
		return ext == ".html"
	case "posts":
		return ext == ".md"
	case "output":
		next, _, _ := strings.Cut(tail, "/")
		switch next {
		case "posts":
			return false
		case "themes":
			return ext == ".html" || ext == ".css" || ext == ".js" || ext == ".md" || ext == ".txt"
		default:
			return ext == ".css" || ext == ".js" || ext == ".md"
		}
	}
	return false
}

func MkdirAll(fsys FS, name string, perm fs.FileMode) error {
	// If the filesystem supports MkdirAll(), we can call that instead and
	// return.
	if fsys, ok := fsys.(interface {
		MkdirAll(name string, perm fs.FileMode) error
	}); ok {
		return fsys.MkdirAll(name, perm)
	}
	fileInfo, err := fs.Stat(fsys, name)
	if err != nil && !errors.Is(err, fs.ErrNotExist) {
		return nil
	}
	if fileInfo != nil {
		if fileInfo.IsDir() {
			return nil
		}
		return &fs.PathError{Op: "mkdirall", Path: name, Err: syscall.ENOTDIR}
	}

	isPathSeparator := func(char byte) bool {
		return char == '/' || char == '\\'
	}

	fixRootDirectory := func(p string) string {
		if runtime.GOOS != "windows" {
			return p
		}
		if len(p) == len(`\\?\c:`) {
			if isPathSeparator(p[0]) && isPathSeparator(p[1]) && p[2] == '?' && isPathSeparator(p[3]) && p[5] == ':' {
				return p + `\`
			}
		}
		return p
	}

	// Slow path: make sure parent exists and then call Mkdir for path.
	i := len(name)
	for i > 0 && isPathSeparator(name[i-1]) { // Skip trailing path separator.
		i--
	}
	j := i
	for j > 0 && !isPathSeparator(name[j-1]) { // Scan backward over element.
		j--
	}

	if j > 1 {
		// Create parent.
		err = MkdirAll(fsys, fixRootDirectory(name[:j-1]), perm)
		if err != nil {
			return err
		}
	}

	// Parent now exists; invoke Mkdir and use its result.
	err = fsys.Mkdir(name, perm)
	if err != nil {
		// I don't know why this is sometimes needed, but it is.
		if errors.Is(err, fs.ErrExist) {
			return nil
		}
		return err
	}
	return nil
}

// RemoveAll removes the root item from the FS (whether it is a file or a
// directory).
func RemoveAll(fsys FS, root string) error {
	type Item struct {
		Path             string // relative to root
		IsFile           bool   // whether item is file or directory
		MarkedForRemoval bool   // if true, remove item unconditionally
	}
	// If the filesystem supports RemoveAll(), we can call that instead and
	// return.
	if fsys, ok := fsys.(interface{ RemoveAll(name string) error }); ok {
		return fsys.RemoveAll(root)
	}
	fileInfo, err := fs.Stat(fsys, root)
	if err != nil {
		if errors.Is(err, fs.ErrNotExist) {
			return nil
		}
		return err
	}
	// If root is a file, we can remove it immediately and return.
	if !fileInfo.IsDir() {
		return fsys.Remove(root)
	}
	var item Item
	var items []Item
	err = fsys.ScanDir(root, func(dirEntry fs.DirEntry) error {
		items = append(items, Item{
			Path:   dirEntry.Name(),
			IsFile: !dirEntry.IsDir(),
		})
		return nil
	})
	if err != nil {
		return err
	}
	// If root is an empty directory, we can remove it immediately and return.
	if len(items) == 0 {
		return fsys.Remove(root)
	}
	// Otherwise, we need to recursively delete its child items one by one.
	for len(items) > 0 {
		// Pop item from stack.
		item, items = items[len(items)-1], items[:len(items)-1]
		// If item has been marked for removal or it is a file, we can remove
		// it immediately.
		if item.MarkedForRemoval || item.IsFile {
			err = fsys.Remove(path.Join(root, item.Path))
			if err != nil {
				return err
			}
			continue
		}
		// Mark directory item for removal and put it back in the stack (when
		// we get back to it, its child items would already have been removed).
		item.MarkedForRemoval = true
		items = append(items, item)
		// Push directory item's child items onto the stack.
		err = fsys.ScanDir(path.Join(root, item.Path), func(dirEntry fs.DirEntry) error {
			items = append(items, Item{
				Path:   filepath.Join(item.Path, dirEntry.Name()),
				IsFile: !dirEntry.IsDir(),
			})
			return nil
		})
		if err != nil {
			return err
		}
	}
	return nil
}
