catalog.go
fs.go
fs_local.go
fs_remote.go
init.go
notebrew.go
template_parser.go
file_handler.go (or filehandler.go?)
createsite.go
deletesite.go
delete.go
...
serve_http.go
notebrew/main.go

scrap the status field
prg is a map[string]string that indicates the request is coming from a post-redirect-get flow, and the "action" field is always present indicating which action initiated the post-redirect-get. Other fields may be filled in as necessary for more information.
    if the prg.action is the current action itself, then the errors may be obtained from the field directly

GET success: status: GET_OK
POST success: status: POST_OK
PRG success: status: PRG_OK
    - action: createsite
    - sitePrefix: sitePrefix

prg: {
    action:
    message:
}

type FormErrors map[string][]map[string]string
type PRG map[string]string

name: [{
    code: MaxSitesReached # leave code out of it until someone needs to programtically assert a form error
    message: this is the thing
}]

TODO: now that createsite is implemented, implement deletesite quickly otherwise you will not be able to deal with the deluge of test data.
TODO: a little "view data" link on file.html that simply the href "?data". When clicked, it generates live data of the page in real time if we're on a page.html, or the latest post/last page data if we're on post.html/postlist.html.
TODO: /users/language/?redirect=foo/bar/baz which lets people set the language code in a cookie and redirects them back to the page. Every page is language-aware by pulling out the language code from the cookie. And then in the notebrew navbar we have a little language switcher icon (a globe) that simply links to /users/language/.
    NOTE: for languages don't parse all the language json files and keep them in memory, instead implement a TTL using timers and timer.Reset everytime someone requests for that language file. Once the timer expires, delete it from the map.
    BEFORE YOU DO THIS: look at how big the language files are. If it's an acceptable cost to keep them all in memory then just keep it in memory and reads will be much faster since you don't have to guard reads behind a mutex.
TODO: rewrite the cookie handling portion of directory.js to mirror the sort/order logic on the server.
TODO: if CMSDomain is not localhost && the CDN link is configured in cdn.txt, we will intercept all generated links and rewrite relative links to CDN links. This means if you're generating pages on localhost, the links are always relative (since GitHub pages etc already host files on their own CDN). And if the user runs their own server but doesn't want to set up the CDN, they can skip configuring the CDN and all the links will stay relative (for max flexibility). Whenever links are rewritten to CDN links you do lose some file flexibility as it means they can no longer be plopped anywhere and just work, it assumes a cdn is up and available as well.

https://www.cs.umd.edu/~ben/goldenrules.html
- Every user action should have feedback. Common user actions can have modest feedback, major user actions should have big feedback.
- Permit easy reversal of actions.

Crazy style guide:
- All JSON properties are PascalCase
- All HTML form names are PascalCase
- All HTML IDs are PascalCase

notebrew-config/
notebrew-users.db
notebrew-files/
notebrew-files.db
notebrew-objects/

notebrew-config/metrics.json (site-specific metrics? or not, since we are aiming to put everything on one server at first)
notebrew-config/metrics.txt
Requests per second (mean) = xxx
Requests per second (Q1)   = xxx
Requests per second (Q2)   = xxx
Requests per second (Q3)   = xxx
Latency (mean) = xxx
Latency (Q1)   = xxx
Latency (Q2)   = xxx
Latency (Q3)   = xxx

TODO: i18n.go
01. en
02. ms
03. zh
04. ja
05. ko
06. es
07. fr
08. it
09. ru
10. pt
