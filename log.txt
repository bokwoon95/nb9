catalog.go
fs.go
fs_local.go
fs_remote.go
creation_time.go
creation_time_linux.go
init.go
notebrew.go
site_generator.go
files.go
regenerate.go
createsite.go
deletesite.go
createfolder.go
createfile.go
delete.go
search.go
clipboard.go
uploadfile.go
rename.go
serve_http.go
notebrew/main.go

TODO: Add a Choose Files file input to the createfile page, when head is posts. It will be uploaded together with the name and content. Brilliant!
TODO: uploadfile.go.
    - OOOH looks like the upload works but the fileID in notebrew-objects/ is all zeroes for some reason.
    - TODO: WTF try deleting GCsDY_vXEAEqTHH.jpeg first, for some reason it's panicking.
        - And when it panics, why does it look like the entire server is taken down? Does the server respond to any other request once it panics? Fix this.
    - 25 MB upload limit.
    - When uploaded to output (i.e. pages/posts/themes), images are always resized to max 1080p. Images in notes are kept untouched. If someone wants to upload a full size image, they can upload it to notes then move it over i to pages/posts/themes, which doesn't incur an additional cost because it's just rewriting metadata.
TODO: file.html: the asset list is UGLY AF, make it look reasonably good while also being accessible on an iPhone SE screen.
    - do uploadfile.go first because we need to upload some images!
    - I think... the best way forward would be to elimate the dropdown and explode the menu into horizontally spread out buttons... (edit|view, rename, cut, copy, delete, (full width) insert into page)
TODO: oh boy pagination on output/themes is broken again (why? investigate)
TODO: once you can upload images with uploadfile, make it so that any image uploaded but is not mentioned in the markdown content (use goldmark's markdown parser for this) is added to the Images field in PostData. Then in the default post.html, loop over the images and display them in a nice grid or something. No image viewer, pure HTML for this. The easiest dumbest way would be to put some kind of overlay <a href> that links directly to the image (so the browser is the image viewer).
    - This way you achieve the ability to upload images easily! No user intervention is needed for manually embedding the images, they can upload images in a dumb and straightforward way akin to facebook.
TODO: rename.go
TODO: /users/language/?redirect=foo/bar/baz which lets people set the language code in a cookie and redirects them back to the page. Every page is language-aware by pulling out the language code from the cookie. And then in the notebrew navbar we have a little language switcher icon (a globe) that simply links to /users/language/.
    NOTE: for languages don't parse all the language json files and keep them in memory, instead implement a TTL using timers and timer.Reset everytime someone requests for that language file. Once the timer expires, delete it from the map.
    BEFORE YOU DO THIS: look at how big the language files are. If it's an acceptable cost to keep them all in memory then just keep it in memory and reads will be much faster since you don't have to guard reads behind a mutex.
TODO: a little "view data" link on file.html that simply the href "?data". When clicked, it generates live data of the page in real time if we're on a page.html, or the latest post/last page data if we're on post.html/postlist.html.
TODO: download.go
    - "download" becomes a new contextual button users can use on selected files, just like cut/copy/delete.
    - a new "download site" button becomes added to a site, which people can use to export their site folders (and upload it back using plain old uploadfile).
    - a corresponding "upload files" option becomes available in the plus icon dropdown menu (separated from create file/create folder by a <hr>).

God the biggest benefit would be me finally having a personal online vault of my own to store fleeting notes and everything I read on the internet everyday.

-- sqlite
select unhex(items.value->>0, '-') as file_id, items.value->>1 as file_path
from json_each('[["e4ac0341-0fd0-4b7c-95f6-f53d9273638c","one"],["f026a58e-8739-4105-b74f-3f2aa8244e4d","two"]]') as items;
select items.value
from json_each('["one","two"]') as items;
-- postgres
select (items.value->>0)::uuid as file_id, items.value->>1 as file_path
from json_array_elements('[["e4ac0341-0fd0-4b7c-95f6-f53d9273638c","one"],["f026a58e-8739-4105-b74f-3f2aa8244e4d","two"]]') as items;
select items.value
from json_array_elements_text('["one","two"]') as items;
-- mysql
select uuid_to_bin(items.file_id) as file_id, items.file_path
from json_table('[["e4ac0341-0fd0-4b7c-95f6-f53d9273638c","one"],["f026a58e-8739-4105-b74f-3f2aa8244e4d","two"]]', '$[*]' columns (file_id char(32) path '$[0]', file_path varchar(500) path '$[1]')) as items;
select items.file_path
from json_table('["one","two"]', '$[*]' columns (file_path varchar(500) path '$')) as items;

files/subscriptions.opml -> view the subscriptions, Google Reader view
files/subscriptions.opml/create/ -> add a new subscription
files/opml/ -> this is the trickiest part. this is where the opml rss feeds are stored site-wide, shared between all subscription files. What's the eviction policy? How do we efficiently join? If we can't efficiently join to display a Google Reader view to the user, should we drop the "backed by a single OPML file" idea and resort to database tables instead? Then we can offer to import/export the data as a opml files. But that means a user not using UsersDB will not be able to use notebrew locally purely as an rss feed reader.

NOTE: `notebrew regenerate` will regenerate all sites. `notebrew regenerate -site ''` will only regenerate the base site. This is great if you change the ImgDomain and need to regenerate all pages in all sites to keep image links up-to-date. notebrew regenerate will rename any posts it finds without a timestamp prefix to include the timestamp prefix (if creation_time can be sourced).

https://www.cs.umd.edu/~ben/goldenrules.html
- Every user action should have feedback. Common user actions can have modest feedback, major user actions should have big feedback.
- Permit easy reversal of actions.

ARM shared vCPUs from Hetzner (trivially upgradeable up to 16 cores, 32 GB RAM and 320 GB disk space).
Backblaze for Storage
BunnyCDN for CDN

notebrew-config/
notebrew-users.db
notebrew-files/
notebrew-files.db
notebrew-objects/

notebrew start | notebrew stop | notebrew status

notebrew-config/metrics.json (site-specific metrics? or not, since we are aiming to put everything on one server at first)
notebrew-config/metrics.txt
Requests per second (mean) = xxx
Requests per second (Q1)   = xxx
Requests per second (Q2)   = xxx
Requests per second (Q3)   = xxx
Latency (mean) = xxx
Latency (Q1)   = xxx
Latency (Q2)   = xxx
Latency (Q3)   = xxx

TODO: wall of banners? submit your banner? randomly arranged banners?

TODO: i18n.go
01. en
02. ms
03. zh
04. ja
05. ko
06. es
07. fr
08. it
09. ru
10. pt
