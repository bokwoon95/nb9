schema.go
fs.go
init.go
status.go
notebrew.go
template_parser.go
file_handler.go
directory.go
file.go
...
serve_http.go
notebrew/main.go

TODO: rethink status.go/error.go. We know most HTTP error statuses are not used (outside of the error handlers), so we can eliminate the dependency on the error statuses from the error handlers.
    TODO: I may commit the sin of putting all the error statuses at the top of notebrew.go instead of in its own file. So the file chain looks like this: init.go -> notebrew.go -> template_parser.go.
TODO: before we put a buffer back into the pool, check if its len is smaller than 2^18. https://victoriametrics.com/blog/tsdb-performance-techniques-sync-pool/

notebrew-config/
notebrew-users.db
notebrew-files/
notebrew-files.db
notebrew-objects/

notebrew-config/metrics.json (site-specific metrics? or not, since we are aiming to put everything on one server at first)
notebrew-config/metrics.txt
Requests per second (mean) = xxx
Requests per second (Q1)   = xxx
Requests per second (Q2)   = xxx
Requests per second (Q3)   = xxx
Latency (mean) = xxx
Latency (Q1)   = xxx
Latency (Q2)   = xxx
Latency (Q3)   = xxx

TODO: i18n.go
1. en
2. zh
3. ja
4. es
5. fr
6. it
7. ru
8. pt
